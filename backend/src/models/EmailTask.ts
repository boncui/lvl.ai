import mongoose, { Schema } from 'mongoose';
import { IBaseTask, TaskType } from './BaseTask';

// ---------- EMAIL TASK INTERFACE ----------
export interface IEmailTask extends IBaseTask {
  // Email-specific fields
  recipient: string;
  recipientName?: string;
  subject: string;
  emailType: 'personal' | 'work' | 'newsletter' | 'follow_up' | 'meeting_request' | 'other';
  emailPriority: 'low' | 'medium' | 'high' | 'urgent';
  isReply: boolean;
  originalEmailId?: string; // Reference to original email if this is a reply
  emailAttachments?: string[]; // Email attachments
  draftContent?: string; // Draft content
  sentAt?: Date;
  readAt?: Date;
  replyReceived?: boolean;
  followUpDate?: Date;
  emailTemplate?: string; // Template used for this email
  
  // Virtual properties
  isOverdue: boolean;
  needsFollowUp: boolean;
  
  // Methods
  markAsSent(): Promise<this>;
  markReplyReceived(): Promise<this>;
  scheduleFollowUp(followUpDate: Date): Promise<this>;
}

// ---------- EMAIL TASK SCHEMA ----------
const EmailTaskSchema = new Schema({
  // Base task fields
  title: {
    type: String,
    required: [true, 'Please add a task title'],
    trim: true,
    maxlength: [200, 'Title cannot be more than 200 characters']
  },
  description: {
    type: String,
    trim: true,
    maxlength: [1000, 'Description cannot be more than 1000 characters']
  },
  taskType: {
    type: String,
    enum: Object.values(TaskType),
    required: [true, 'Please specify task type'],
    default: TaskType.EMAIL
  },
  emailPriority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'cancelled'],
    default: 'pending'
  },
  dueDate: { type: Date },
  startDate: { type: Date },
  completedAt: { type: Date },
  estimatedDuration: {
    type: Number,
    min: [1, 'Duration must be at least 1 minute']
  },
  actualDuration: {
    type: Number,
    min: [1, 'Duration must be at least 1 minute']
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [50, 'Tag cannot be more than 50 characters']
  }],
  assignee: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  assignedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  collaborators: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  location: {
    type: String,
    trim: true,
    maxlength: [200, 'Location cannot be more than 200 characters']
  },
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurringPattern: {
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly', 'yearly']
    },
    interval: {
      type: Number,
      min: [1, 'Interval must be at least 1']
    },
    daysOfWeek: [{
      type: Number,
      min: 0,
      max: 6
    }],
    dayOfMonth: {
      type: Number,
      min: 1,
      max: 31
    },
    endDate: {
      type: Date
    }
  },
  parentTask: {
    type: Schema.Types.ObjectId,
    ref: 'EmailTask'
  },
  subtasks: [{
    type: Schema.Types.ObjectId,
    ref: 'EmailTask'
  }],
  emailAttachments: [{
    type: String,
    trim: true
  }],
  notes: [{
    content: {
      type: String,
      required: true,
      maxlength: [500, 'Note cannot be more than 500 characters']
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  }],
  reminders: [{
    date: {
      type: Date,
      required: true
    },
    message: {
      type: String,
      maxlength: [200, 'Reminder message cannot be more than 200 characters']
    },
    isSent: {
      type: Boolean,
      default: false
    }
  }],
  xpValue: {
    type: Number,
    default: 10,
    min: [0, 'XP value cannot be negative']
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  
  // Email-specific fields
  recipient: {
    type: String,
    required: [true, 'Please specify the recipient email'],
    trim: true,
    lowercase: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      'Please add a valid email address'
    ]
  },
  recipientName: {
    type: String,
    trim: true,
    maxlength: [100, 'Recipient name cannot be more than 100 characters']
  },
  subject: {
    type: String,
    required: [true, 'Please add an email subject'],
    trim: true,
    maxlength: [200, 'Subject cannot be more than 200 characters']
  },
  emailType: {
    type: String,
    enum: ['personal', 'work', 'newsletter', 'follow_up', 'meeting_request', 'other'],
    required: [true, 'Please specify the email type'],
    default: 'other'
  },
  isReply: {
    type: Boolean,
    default: false
  },
  originalEmailId: {
    type: String,
    trim: true
  },
  draftContent: {
    type: String,
    trim: true,
    maxlength: [5000, 'Draft content cannot be more than 5000 characters']
  },
  sentAt: {
    type: Date
  },
  readAt: {
    type: Date
  },
  replyReceived: {
    type: Boolean,
    default: false
  },
  followUpDate: {
    type: Date
  },
  emailTemplate: {
    type: String,
    trim: true,
    maxlength: [100, 'Template name cannot be more than 100 characters']
  }
}, {
  timestamps: true
});

// Set default taskType
EmailTaskSchema.add({ taskType: { type: String, default: TaskType.EMAIL } });

// Email-specific indexes
EmailTaskSchema.index({ assignee: 1, recipient: 1 });
EmailTaskSchema.index({ assignee: 1, emailType: 1 });
EmailTaskSchema.index({ sentAt: -1 });
EmailTaskSchema.index({ followUpDate: 1 });

// Virtual for checking if email is overdue
EmailTaskSchema.virtual('isOverdue').get(function() {
  return this['followUpDate'] && this['followUpDate'] < new Date() && this['status'] !== 'completed';
});

// Virtual for checking if email needs follow-up
EmailTaskSchema.virtual('needsFollowUp').get(function() {
  return this['sentAt'] && !this['replyReceived'] && this['followUpDate'] && this['followUpDate'] < new Date();
});

// Method to mark email as sent
EmailTaskSchema.methods['markAsSent'] = function() {
  this['sentAt'] = new Date();
  this['status'] = 'completed';
  return this['save']();
};

// Method to mark reply as received
EmailTaskSchema.methods['markReplyReceived'] = function() {
  this['replyReceived'] = true;
  this['readAt'] = new Date();
  return this['save']();
};

// Method to schedule follow-up
EmailTaskSchema.methods['scheduleFollowUp'] = function(followUpDate: Date) {
  this['followUpDate'] = followUpDate;
  this['status'] = 'pending';
  return this['save']();
};

const EmailTask = mongoose.model<IEmailTask>('EmailTask', EmailTaskSchema);
export default EmailTask;
