import mongoose, { Schema } from 'mongoose';
import { IBaseTask, TaskType } from './BaseTask';

// ---------- MEETING TASK INTERFACE ----------
export interface IMeetingTask extends IBaseTask {
  // Meeting-specific fields
  meetingType: 'team_meeting' | 'one_on_one' | 'client_meeting' | 'interview' | 'presentation' | 'workshop' | 'other';
  attendees: mongoose.Types.ObjectId[]; // User IDs of attendees
  attendeeEmails?: string[]; // External attendees
  meetingRoom?: string;
  meetingLink?: string; // For virtual meetings
  agenda?: string[];
  meetingNotes?: string;
  actionItems?: {
    item: string;
    assignee: mongoose.Types.ObjectId;
    dueDate?: Date;
    completed: boolean;
  }[];
  meetingDuration: number; // in minutes
  actualDuration?: number; // in minutes
  meetingOutcome?: 'successful' | 'needs_follow_up' | 'cancelled' | 'rescheduled';
  nextMeetingDate?: Date;
  recurringMeeting?: boolean;
  meetingSeriesId?: string; // For recurring meetings
}

// ---------- MEETING TASK SCHEMA ----------
const MeetingTaskSchema = new Schema({
  // Base task fields
  title: {
    type: String,
    required: [true, 'Please add a task title'],
    trim: true,
    maxlength: [200, 'Title cannot be more than 200 characters']
  },
  description: {
    type: String,
    trim: true,
    maxlength: [1000, 'Description cannot be more than 1000 characters']
  },
  taskType: {
    type: String,
    enum: Object.values(TaskType),
    required: [true, 'Please specify task type'],
    default: TaskType.MEETING
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'cancelled'],
    default: 'pending'
  },
  dueDate: { type: Date },
  startDate: { type: Date },
  completedAt: { type: Date },
  estimatedDuration: {
    type: Number,
    min: [1, 'Duration must be at least 1 minute']
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [50, 'Tag cannot be more than 50 characters']
  }],
  assignee: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  assignedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  collaborators: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  location: {
    type: String,
    trim: true,
    maxlength: [200, 'Location cannot be more than 200 characters']
  },
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurringPattern: {
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly', 'yearly']
    },
    interval: {
      type: Number,
      min: [1, 'Interval must be at least 1']
    },
    daysOfWeek: [{
      type: Number,
      min: 0,
      max: 6
    }],
    dayOfMonth: {
      type: Number,
      min: 1,
      max: 31
    },
    endDate: {
      type: Date
    }
  },
  parentTask: {
    type: Schema.Types.ObjectId,
    ref: 'MeetingTask'
  },
  subtasks: [{
    type: Schema.Types.ObjectId,
    ref: 'MeetingTask'
  }],
  attachments: [{
    filename: {
      type: String,
      required: true
    },
    url: {
      type: String,
      required: true
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  notes: [{
    content: {
      type: String,
      required: true,
      maxlength: [500, 'Note cannot be more than 500 characters']
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  }],
  reminders: [{
    date: {
      type: Date,
      required: true
    },
    message: {
      type: String,
      maxlength: [200, 'Reminder message cannot be more than 200 characters']
    },
    isSent: {
      type: Boolean,
      default: false
    }
  }],
  xpValue: {
    type: Number,
    default: 10,
    min: [0, 'XP value cannot be negative']
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  
  // Meeting-specific fields
  meetingType: {
    type: String,
    enum: ['team_meeting', 'one_on_one', 'client_meeting', 'interview', 'presentation', 'workshop', 'other'],
    required: [true, 'Please specify the meeting type'],
    default: 'other'
  },
  attendees: [{
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }],
  attendeeEmails: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  meetingRoom: {
    type: String,
    trim: true,
    maxlength: [100, 'Meeting room cannot be more than 100 characters']
  },
  meetingLink: {
    type: String,
    trim: true
  },
  agenda: [{
    type: String,
    trim: true,
    maxlength: [200, 'Agenda item cannot be more than 200 characters']
  }],
  meetingNotes: {
    type: String,
    trim: true,
    maxlength: [2000, 'Meeting notes cannot be more than 2000 characters']
  },
  actionItems: [{
    item: {
      type: String,
      required: true,
      trim: true,
      maxlength: [200, 'Action item cannot be more than 200 characters']
    },
    assignee: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    dueDate: {
      type: Date
    },
    completed: {
      type: Boolean,
      default: false
    }
  }],
  meetingDuration: {
    type: Number,
    required: [true, 'Please specify meeting duration'],
    min: [5, 'Meeting duration must be at least 5 minutes']
  },
  actualDuration: {
    type: Number,
    min: [1, 'Actual duration must be at least 1 minute']
  },
  meetingOutcome: {
    type: String,
    enum: ['successful', 'needs_follow_up', 'cancelled', 'rescheduled'],
    default: 'successful'
  },
  nextMeetingDate: {
    type: Date
  },
  recurringMeeting: {
    type: Boolean,
    default: false
  },
  meetingSeriesId: {
    type: String,
    trim: true
  }
}, {
  timestamps: true
});

// Set default taskType
MeetingTaskSchema.add({ taskType: { type: String, default: TaskType.MEETING } });

// Meeting-specific indexes
MeetingTaskSchema.index({ assignee: 1, meetingType: 1 });
MeetingTaskSchema.index({ attendees: 1 });
MeetingTaskSchema.index({ startDate: 1 });
MeetingTaskSchema.index({ meetingSeriesId: 1 });

// Virtual for checking if meeting is happening now
MeetingTaskSchema.virtual('isHappeningNow').get(function() {
  const now = new Date();
  return this['startDate'] && this['startDate'] <= now && 
         this['dueDate'] && this['dueDate'] >= now && 
         this['status'] !== 'completed';
});

// Virtual for calculating meeting efficiency
MeetingTaskSchema.virtual('meetingEfficiency').get(function() {
  if (!this['meetingDuration'] || !this['actualDuration']) return null;
  return (this['meetingDuration'] / this['actualDuration']) * 100;
});

// Method to add attendee
MeetingTaskSchema.methods['addAttendee'] = function(userId: string) {
  if (!this['attendees'].includes(userId)) {
    this['attendees'].push(userId);
  }
  return this['save']();
};

// Method to add action item
MeetingTaskSchema.methods['addActionItem'] = function(item: string, assigneeId: string, dueDate?: Date) {
  this['actionItems'].push({
    item,
    assignee: assigneeId,
    dueDate,
    completed: false
  });
  return this['save']();
};

// Method to complete action item
MeetingTaskSchema.methods['completeActionItem'] = function(actionItemIndex: number) {
  if (this['actionItems'][actionItemIndex]) {
    this['actionItems'][actionItemIndex].completed = true;
  }
  return this['save']();
};

const MeetingTask = mongoose.model<IMeetingTask>('MeetingTask', MeetingTaskSchema);
export default MeetingTask;
