import mongoose, { Schema } from 'mongoose';
import { IBaseTask, TaskType } from './BaseTask';

// ---------- FOOD TASK INTERFACE ----------
export interface IFoodTask extends IBaseTask {
  // Food-specific fields
  foodName: string;
  category: 'Breakfast' | 'Lunch' | 'Dinner' | 'Snack' | 'Drink';
  calories: number;
  protein?: number;
  carbs?: number;
  fats?: number;
  sugar?: number;
  fiber?: number;
  cost?: number; // in USD
  cookTime?: number; // in minutes
  ingredients?: string[];
  healthRating?: 1 | 2 | 3 | 4 | 5; // Poor to Superfood
  moodAfterEating?: string;
  source?: string; // e.g. "Home-cooked", "Restaurant", "Delivery"
  image?: string;
  loggedAt: Date;
  aiSuggestions?: {
    substitute?: string;
    tip?: string;
  };
}

// ---------- FOOD TASK SCHEMA ----------
const FoodTaskSchema = new Schema({
  // Base task fields
  title: {
    type: String,
    required: [true, 'Please add a task title'],
    trim: true,
    maxlength: [200, 'Title cannot be more than 200 characters']
  },
  description: {
    type: String,
    trim: true,
    maxlength: [1000, 'Description cannot be more than 1000 characters']
  },
  taskType: {
    type: String,
    enum: Object.values(TaskType),
    required: [true, 'Please specify task type'],
    default: TaskType.FOOD
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'cancelled'],
    default: 'pending'
  },
  dueDate: { type: Date },
  startDate: { type: Date },
  completedAt: { type: Date },
  estimatedDuration: {
    type: Number,
    min: [1, 'Duration must be at least 1 minute']
  },
  actualDuration: {
    type: Number,
    min: [1, 'Duration must be at least 1 minute']
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [50, 'Tag cannot be more than 50 characters']
  }],
  assignee: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  assignedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  collaborators: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  location: {
    type: String,
    trim: true,
    maxlength: [200, 'Location cannot be more than 200 characters']
  },
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurringPattern: {
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly', 'yearly']
    },
    interval: {
      type: Number,
      min: [1, 'Interval must be at least 1']
    },
    daysOfWeek: [{
      type: Number,
      min: 0,
      max: 6
    }],
    dayOfMonth: {
      type: Number,
      min: 1,
      max: 31
    },
    endDate: {
      type: Date
    }
  },
  parentTask: {
    type: Schema.Types.ObjectId,
    ref: 'FoodTask'
  },
  subtasks: [{
    type: Schema.Types.ObjectId,
    ref: 'FoodTask'
  }],
  attachments: [{
    filename: {
      type: String,
      required: true
    },
    url: {
      type: String,
      required: true
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  notes: [{
    content: {
      type: String,
      required: true,
      maxlength: [500, 'Note cannot be more than 500 characters']
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  }],
  reminders: [{
    date: {
      type: Date,
      required: true
    },
    message: {
      type: String,
      maxlength: [200, 'Reminder message cannot be more than 200 characters']
    },
    isSent: {
      type: Boolean,
      default: false
    }
  }],
  xpValue: {
    type: Number,
    default: 10,
    min: [0, 'XP value cannot be negative']
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  
  // Food-specific fields
  foodName: {
    type: String,
    required: [true, 'Please add a food name'],
    trim: true,
    maxlength: [100, 'Food name cannot be more than 100 characters']
  },
  category: {
    type: String,
    enum: ['Breakfast', 'Lunch', 'Dinner', 'Snack', 'Drink'],
    required: [true, 'Please specify the food category']
  },
  calories: {
    type: Number,
    required: [true, 'Please add calorie count'],
    min: [0, 'Calories cannot be negative']
  },
  protein: { type: Number, min: [0, 'Protein cannot be negative'] },
  carbs: { type: Number, min: [0, 'Carbs cannot be negative'] },
  fats: { type: Number, min: [0, 'Fats cannot be negative'] },
  sugar: { type: Number, min: [0, 'Sugar cannot be negative'] },
  fiber: { type: Number, min: [0, 'Fiber cannot be negative'] },
  cost: { type: Number, min: [0, 'Cost cannot be negative'] },
  cookTime: { type: Number, min: [0, 'Cook time cannot be negative'] },
  ingredients: [{
    type: String,
    trim: true,
    maxlength: [100, 'Ingredient name cannot be more than 100 characters']
  }],
  healthRating: {
    type: Number,
    enum: [1, 2, 3, 4, 5],
    default: 2
  },
  moodAfterEating: {
    type: String,
    trim: true,
    maxlength: [100, 'Mood description cannot be more than 100 characters']
  },
  source: {
    type: String,
    trim: true,
    maxlength: [50, 'Source cannot be more than 50 characters']
  },
  image: { type: String, trim: true },
  loggedAt: { type: Date, default: Date.now },
  aiSuggestions: {
    substitute: {
      type: String,
      trim: true,
      maxlength: [200, 'Substitute suggestion cannot be more than 200 characters']
    },
    tip: {
      type: String,
      trim: true,
      maxlength: [200, 'Tip cannot be more than 200 characters']
    }
  }
}, {
  timestamps: true
});

// Set default taskType
FoodTaskSchema.add({ taskType: { type: String, default: TaskType.FOOD } });

// Food-specific indexes
FoodTaskSchema.index({ assignee: 1, category: 1 });
FoodTaskSchema.index({ assignee: 1, loggedAt: -1 });
FoodTaskSchema.index({ healthRating: 1 });

// Virtual for calculating total macros
FoodTaskSchema.virtual('totalMacros').get(function() {
  const protein = this['protein'] || 0;
  const carbs = this['carbs'] || 0;
  const fats = this['fats'] || 0;
  return protein + carbs + fats;
});

// Virtual for checking if food is healthy
FoodTaskSchema.virtual('isHealthy').get(function() {
  return this['healthRating'] && this['healthRating'] >= 3;
});

// Method to add an ingredient
FoodTaskSchema.methods['addIngredient'] = function(ingredient: string) {
  if (!this['ingredients'].includes(ingredient)) {
    this['ingredients'].push(ingredient);
  }
  return this['save']();
};

// Method to update AI suggestions
FoodTaskSchema.methods['updateAISuggestions'] = function(substitute?: string, tip?: string) {
  if (substitute) this['aiSuggestions'].substitute = substitute;
  if (tip) this['aiSuggestions'].tip = tip;
  return this['save']();
};

// Method to calculate nutritional density (calories per gram of macros)
FoodTaskSchema.methods['getNutritionalDensity'] = function() {
  const totalMacros = this['totalMacros'];
  return totalMacros > 0 ? this['calories'] / totalMacros : 0;
};

const FoodTask = mongoose.model<IFoodTask>('FoodTask', FoodTaskSchema);
export default FoodTask;
